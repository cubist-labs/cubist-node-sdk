"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreCompileManifest = exports.FileArtifact = void 0;
const fs = __importStar(require("fs"));
const validator_1 = require("./schema/validator");
/** @internal A file produced during the 'pre-compile' step. */
class FileArtifact {
}
exports.FileArtifact = FileArtifact;
/** @internal Manifest generated by `cubist pre-compile`. This class is a
 * subset of our Rust SDK `PreCompileManifest` struct, intended to be used for
 * reading pre-compile manifest files (but not writing them).
 *
 * Manifests contains info about the original as well as generated
 * (shim/interface) contracts. These files are, by default, stored within the
 * contracts directory of each target build (see Path below).
 *
 * Path: `{build_dir}/{target}/contracts/cubist-manifest.json`
 *
 * Example JSON file produced by `cubist pre-compile`:
 * ```json
 * {
 *    "files": [
 *        {
 *            "is_shim": false,
 *            "rel_path": "poly.sol",
 *            "contract_dependencies": {
 *               "PolyCounter": [ "EthCounter" ]
 *            }
 *        },
 *        {
 *           "is_shim": true,
 *           "rel_path": "EthCounter.sol",
 *           "contract_dependencies": {
 *              "EthCounter": []
 *           }
 *        }
 *    ]
 * }
 * ```
 *
 * This manifest tells other `cubist` commands where to find contract files
 * (`poly.sol`) for the target chain and which source files have generated shim
 * contracts (`EthCounter.sol`). It's also used by this SDK e.g., to implement
 * {@link ContractFactory.deploy}.
 *
 * **NOTE**: Most users don't need to use this class; manifests are internal to
 * Cubist. */
class PreCompileManifest {
    /** Produced files. */
    get files() {
        return this._files;
    }
    /** @ignore Empty constructor */
    constructor() {
        // @eslint-disable-line @typescript-eslint/no-empty-function
    }
    /**
     * Create manifest from JSON file.
     * @param {PathBuf} file Path to the manifest file.
     * @return {PreCompileManifest} the manifest.
     */
    static from_file(file) {
        // Read the manifest file
        const json = JSON.parse(fs.readFileSync(file, 'utf8'));
        return PreCompileManifest._from_json(json);
    }
    /**
     * Create manifest from JSON object.
     *
     * This is largely used for testing. This function is not exposed in the Rust
     * SDK; it might go away from the JS SDK as well.
     *
     * @param {IPreCompileManifest} json the manifest object.
     * @return {PreCompileManifest} the manifest.
     * @internal
     */
    static _from_json(json) {
        // Read the config file
        const self = new PreCompileManifest();
        // Validate the json against the schema
        (0, validator_1.validatePreCompileManifest)(json);
        // Populate the object
        self._files = json.files;
        return self;
    }
}
exports.PreCompileManifest = PreCompileManifest;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJlX2NvbXBpbGVfbWFuaWZlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY29uZmlnL3ByZV9jb21waWxlX21hbmlmZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdUNBQXlCO0FBQ3pCLGtEQUFpRTtBQXVDakUsK0RBQStEO0FBQy9ELE1BQWEsWUFBWTtDQVF4QjtBQVJELG9DQVFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2FBc0NhO0FBQ2IsTUFBYSxrQkFBa0I7SUFDN0Isc0JBQXNCO0lBQ3RCLElBQUksS0FBSztRQUNQLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUNyQixDQUFDO0lBR0QsZ0NBQWdDO0lBQ2hDO1FBQ0UsNERBQTREO0lBQzlELENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLFNBQVMsQ0FBQyxJQUFhO1FBQzVCLHlCQUF5QjtRQUN6QixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxZQUFZLENBQUMsSUFBSSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7UUFFdkQsT0FBTyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0MsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNILE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBeUI7UUFDekMsdUJBQXVCO1FBQ3ZCLE1BQU0sSUFBSSxHQUFHLElBQUksa0JBQWtCLEVBQUUsQ0FBQztRQUV0Qyx1Q0FBdUM7UUFDdkMsSUFBQSxzQ0FBMEIsRUFBQyxJQUFJLENBQUMsQ0FBQztRQUVqQyxzQkFBc0I7UUFDdEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBRXpCLE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztDQUNGO0FBOUNELGdEQThDQyJ9