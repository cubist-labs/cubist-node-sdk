import { Config, ContractName, PathBuf, Target } from './config';
import { TargetProject } from './internal';
import * as internal from './internal';
/** Contract address (string).
 * @group Core
 * */
export type ContractAddress = internal.ContractAddress;
/**
 * Account address (string)
 * @group Core
 * */
export type AccountAddress = internal.AccountAddress;
export * from './config';
/** @group Internal */
export * as internal from './internal';
/** @group Core */
export { BigNumber, } from './internal';
/** @group Internal */
export { solidity, } from './internal';
/**
 * Alias to ether.js' Contract.
 * @group Core
 * */
export type EthersContract = internal.Contract;
/** @ignore */
export { find_file, } from './utils';
/**
 * Fully qualified contracts name.
 * @group Internal
 * */
export interface ContractFQN {
    /** Name of the file where the contract is defined. */
    readonly file: PathBuf;
    /** Contract name. */
    readonly name: ContractName;
}
/** @internal Target and address of a deployed contract. */
export interface DeploymentInfo {
    /** Chain to which the contract was deployed */
    readonly target: Target;
    /** Contract address */
    readonly address: ContractAddress;
}
/** @internal Per-contract manifest generated by the deployer. */
export interface DeploymentManifest extends DeploymentInfo {
    /** Deployed contract */
    readonly contract: ContractFQN;
    /** All of its shims' deployment infos */
    readonly shims: DeploymentInfo[];
}
/**
 * This class is _the_ way to work with interface with your cubist
 * projects. This class abstracts over all contracts and contract factories.
 *
 * @example Create a new project to access contracts and their factories:
 *
 * ```typescript
 * const cubist = new Cubist();
 * // get contract factory
 * const Receiver = cubist.getContractFactory('Receiver');
 * // deploy Receiver, ...
 *
 * // get already deployed Sender contract
 * const senderInstance = cubist.getContract('Sender');
 *
 * // wait for bridge to spin up
 * assert(await cubist.whenBridged());
 * ```
 *
 * Beyond exposing project {@link Contract | contracts} (via {@link
 * getContract}) and {@link ContractFactory | contract factories} (via {@link
 * getContractFactory}), projects can wait for bridges (between contracts and
 * cross-chain shims they call) to start up with {@link whenBridged}.
 *
 * At build time, `cubist build` generates a [CubistORM] class that extends
 * {@link Cubist} with the project-specific factories (see
 * [Overview](/jsdoc/)). This means, in practice, you don't even need to use
 * {@link getContract} and {@link getContractFactory}.
 *
 * @example Create a new project to access contracts and their factories with [CubistORM]:
 *
 * ```typescript
 * import { CubistORM, } from '../build/orm/index.js';
 *
 * const cubist = new CubistORM();
 * // get contract factory
 * const Receiver = cubist.Receiver;
 * // deploy Receiver, ...
 *
 * // get already deployed Sender contract
 * const senderInstance = cubist.Sender.attach();
 *
 * // wait for bridge to spin up
 * assert(await cubist.whenBridged());
 * ```
 *
 * [CubistORM]: /jsdoc-md/cubist.CubistORM
 *
 * @group Core
 */
export declare class Cubist {
    /** Underlying configuration. */
    readonly config: Config;
    private readonly targetMap;
    private readonly contractMap;
    private readonly shimMap;
    private readonly deps;
    private _initialized;
    /** Create new project. The constructor looks for the nearest
     * `cubist-config.json`, i.e., it looks in the current directory and every
     * parent directory until it finds the config.
     *
     * If the code using this SDK is not in the same directory tree, though, you
     * can pass an explicit config:
     *
     * ```typescript
     * const config = new Config('/path/to/your/cubist-config.json');
     * const cubist = new Cubist (config);
     * ```
     *
     * In the future this argument might change, e.g., to a filename instead of
     * explicit {@link Config}.
     *
     * @param {Config?} config - Optional config (using near otherwise).
     * */
    constructor(config?: Config);
    /**
     * @internal Finish initializing the instance by loading the contract and
     * shim maps.
     */
    private lazyInitialize;
    /** Get contract factory given the contract name.
    * @param {ContractName} name - The contract name.
    * @return {ContractFactory} The contract factory.
    * */
    getContractFactory<T extends internal.Contract>(name: ContractName): ContractFactory<T>;
    /** Get an existing deployed contract. This method looks up the contract's
     * deploy receipts in the `deploy` directory unless you explicitly tell it to
     * `ignoreReceipt`s (e.g., because you're trying to get a contract deployed
     * with another tool).
     *
     * :::note
     * For now we only support deploying a contract once so calling
     * `getContract` with the same name but different addresses is not yet
     * supported.
     * :::
     *
     * @param {ContractName} name - The contract name.
     * @param {ContractAddress?} addr - Optional contract address (if more than
     * one contract with same name).
     * @param {boolean} ignoreReceipt - Ignore receipt (e.g., if contract deployed
     * with another tool).
     * @return {Contract<T>} The contract.
     * @throws {Error} If the contract could not be found, if there are multiple
     * contracts and the address argument is omitted, or if the receipt is missing
     * (unless ignoreReceipt is set).
     * */
    getContract<T extends internal.Contract>(name: ContractName, addr?: ContractAddress, ignoreReceipt?: boolean): Contract<T>;
    /**
     * Returns a promise that completes once bridges have been established for
     * all contracts in this projects.
     *
     * @param {number} retries - how many times to check
     * @param {number} delayMs - delay in milliseconds between checks
     * @return {boolean} - true if all bridges have been established
     * @throws {Error} if any contract in this project has not been deployed
     */
    whenBridged(retries?: number, delayMs?: number): Promise<boolean>;
}
/**
 * Contract factories are used to create {@link Contract}s that span multiple
 * chains. Specifically, with a factory you can use:
 *
 * - {@link deploy} to deploy a {@link Contract} to its native target chain _and_
 *   automatically deploy its shims to the chains where this contract gets
 *   called.
 * - {@link deployShims} to deploy only the shims of the contract on all the
 *   chains the contract is called.
 * - {@link deployWithShims} to deploy the contract to its native target chain
 *   (given its already deployed shims). Together, {@link deployShims} and
 *   {@link deployWithShims}, make it possible to deploy shims before the
 *   native contract.
 * - {@link attach} to attach to an already deployed contract. This is the same
 *   as {@link Cubist.getContract}. We expose {@link attach} because the
 *   well-typed {@link Cubist} interface we generate at build time (with
 *   `cubist build`)---[CubistORM]---exports the project factories as
 *   properties on the object, eliding the need to use `getContractFactory` and
 *   `getContract`.
 *
 * @example
 * Get factory and deploy contract and its shims with {@link Cubist}.
 * ```typescript
 * const StorageReceiver = cubist.getContractFactory('StorageReceiver');
 * const receiver = await StorageReceiver.deploy(33);
 * ```

 * @example
 * Get factory and attach to existing deployed contract.
 * ```typescript
 * import { CubistORM, } from '../build/orm/index.js';
 * // ...
 * const StorageReceiver = cubist.StorageReceiver;
 * const receiver = StorageReceiver.attach();
 * ```
 *
 * [CubistORM]: /jsdoc-md/cubist.CubistORM
 *
 * @group Core
 * */
export declare class ContractFactory<T extends internal.Contract> {
    private readonly name;
    private readonly cubist;
    private readonly internalFactory;
    private readonly shimFactoryMap;
    private readonly shimDeps;
    /** Underlying target project. */
    readonly project: TargetProject;
    /** @internal Create new contract factory. The constructor is not intended to be called
     * directly. Use `getContractFactory` from the `Cubist` class instead.
     * @param {ContractName} name - The contract name.
     * @param {Cubist} cubist - The parent cubist project.
     * @param {TargetProject} project - The target chain project.
     * @param {internal.ContractFactory} internalFactory - The underlying contract factory.
     * @param {Map<Target, internal.ContractFactory>} shimFactoryMap - Map of shim contract factories.
     * @param {Set<ContractName>} shimDeps - Shims on this chain that this contract may call.
      */
    constructor(name: ContractName, cubist: Cubist, project: TargetProject, internalFactory: internal.ContractFactory, shimFactoryMap: Map<Target, internal.ContractFactory>, shimDeps: Set<ContractName>);
    /** Deploy contract and its shims.
     * This function deploys the contract to its target chain, and the shims to
     * their corresponding chains. We return a contract that encapsulates an
     * inner [ethers.js
     * Contract](https://docs.ethers.org/v5/api/contract/contract/) and exposes
     * some additional methods for interacting with the shims.
     *
     * :::note
     * For now, you can only deploy a single instance of a contract. The next
     * release of cubist will have support for multiple instances (Issue #580).
     * :::
     *
     * @param {any[]} args - Arguments to call contract constructor with.
     * @return {Promise<Contract>} The deployed contract.
     * */
    deploy(...args: any[]): Promise<Contract<T>>;
    /** Deploy contract given the already-deployed shims.
     * This function deploys the {@link Contract} to its native target chain.
     * The first argument is the return value from the {@link deployShims} function.
     * The rest of the arguments are the constructor arguments.
     *
     * This function is useful for deploying cross-chain contracts that mutually
     * depend on each other.
     *
     * @param {Map<Target, T>} shims - the previously deployed shims.
     * @param {any[]} args - Arguments to pass to call contract constructor with.
     * @return {Promise<Contract>} The deployed contract.
     * */
    deployWithShims(shims: Map<Target, T>, ...args: any[]): Promise<Contract<T>>;
    /** Deploy shims for this contract. In some cases you need to deploy the
     * contract shims before the contract itself (see our [TokenBridge] for an
     * example). This method is used to do deploy the shims, which you can then
     * use when deploying the contract itself with {@link deployWithShims}.
     *
     * @example In our [TokenBridge] template (`cubist new --template
     * TokenBridge`) we set up a two way bridge across two chains and need to
     * deploy shims on one end to handle the circular dependency---the two
     * contracts mutually depend on each other.
     *
     * ```typescript
     * // deploy ERC20Bridged shims
     * const erc20bShims = await ERC20Bridged.deployShims();
     * // get the shim contract on the token sender chain
     * const erc20BridgedShim = erc20bShims.get(TokenSender.target());
     * // deploy the token sender contract and its shim
     * const tokenSender = await TokenSender.deploy(erc20BridgedShim.address);
     * // Deploy ERC20Bridged with the TokenSender address.
     * const erc20Bridged = await ERC20Bridged.deployWithShims(erc20bShims,
     * ```
     * @return {Promise<Map<Target, T>>} The deployed shims.
     *
     * [TokenBridge]: /guide/advanced-examples/Cross-chain-token-bridge
     */
    deployShims(): Promise<Map<Target, T>>;
    /** Get the already-deployed contract.
     * @return {Promise<Contract>} The deployed contract.
     */
    deployed(): Promise<Contract<T>>;
    /** Get the already-deployed contract at particular address.
     * @param {ContractAddress} addr - Contract address.
     * @return {Promise<Contract>} The deployed contract.
     */
    attach(addr: ContractAddress): Promise<Contract<T>>;
    /** Deploy shim contract.
     * @param {Target} target - The target chain to deploy shim to.
     * @return {Promise<internal.Contract>} The deployed contract.
     * */
    private deployShim;
    /** Get (native) target chain.
     * @return {Target} The target chain.
     * */
    target(): Target;
}
/**
 * Multi-chain contract abstraction. Each Cubist contract encapsulates (for
 * now) an [ethers.js
 * Contract](https://docs.ethers.org/v5/api/contract/contract/)) that runs on a
 * _native target chain_ and zero or more _shim contracts_ running on other
 * chains.
 *
 * A contract deployed with {@link ContractFactory} is deployed to the chain
 * specified in the `cubist-config.json` configuration file; this is the native
 * target chain. If this contract is called on another chain, we also deploy
 * a _shim_ for this contract on that chain (either automatically when you use
 * {@link ContractFactory.deploy} or manually when you use
 * {@link ContractFactory.deployShims}).
 *
 * This class exposes the contract on the native target chains (via {@link
 * inner}), and several methods for getting the contract {@link target} chain,
 * its {@link address} on the native target chain, and its shims' {@link
 * addressOn | addresses on} other chains.
 *
 * @example ERC20 bridged from Avalanche to Polygon and Ethereum has a native
 * contract on Avalanche and corresponding shims on the other two chains.
 *
 * ```typescript
 * // ...
 * const cubist = new Cubist();
 * // get contract
 * const e20Bridged = cubist.getContract('ERC20Bridged');
 * // print its address on native chain
 * console.log(`address on ${e20Bridged.target()}: ${e20Bridged.address()}`);
 * // print its shims' addresses
 * console.log(`address on Polygon: ${e20Bridged.addressOn(Target.Polygon)}`);
 * console.log(`address on Ethereum: ${e20Bridged.addressOn(Target.Ethereum)}`);
 * ```
 *
 * @group Core
 * */
export declare class Contract<T extends internal.Contract> {
    /** The single-chain target project corresponding to the target chain this
     * contract was deployed to. In general you don't need to access the project
    * itself. */
    readonly project: TargetProject;
    /** Fully qualified contract name. */
    readonly fqn: ContractFQN;
    /**
     * The underlying (for now
     * [ethers.js](https://docs.ethers.org/v5/api/contract/contract/)) native
     * contract. This is ultimately the contract you will invoke methods on,
     * listen for events on, etc.
     * */
    readonly inner: T;
    /** Any shims that may be defined for other chains. */
    private readonly shims;
    /** @return {Target} - The target chain the contract was deployed to. */
    target(): Target;
    /** @internal Create new contract. The constructor is not intended to be called
     * directly. Use {@link Cubist.getContract} instead (or get a
     * contract by {@link deploy}ing it via a factory).
     * @param {TargetProject} target - The target chain project.
     * @param {ContractFQN} fqn - The contract fully qualified name.
     * @param {T} inner - The underlying contract.
     * @param {Map<Target, internal.Contract>} shims - Map of shim contracts.
     */
    constructor(target: TargetProject, fqn: ContractFQN, inner: T, shims: Map<Target, internal.Contract>);
    /** Get contract address of this contract on a particular target chain.
     * @param {Target} target - The target chain.
     * @return {ContractAddress} The contract address.
     */
    addressOn(target: Target): ContractAddress;
    /** Get contract address on the native target chain.
     * @return {ContractAddress} The contract address.
     */
    address(): ContractAddress;
    /**
     * Returns a promise that completes once the bridge between this contract and
     * its shims has been established. In general, you don't need to call this
     * yourself; the top-level {@link Cubist.whenBridged} does this for all contracts.
     *
     * @param {number} retries - how many times to check if the bridge has been established.
     * @param {number} delayMs - delay in milliseconds between retries.
     * @return {boolean} - whether a bridge has been established within the given time parameters.
     */
    whenBridged(retries?: number, delayMs?: number): Promise<boolean>;
    /**
     * @internal
     * Creates a manifest for this contract and saves it to disk (in the {@link
     * Config.deploy_dir} directory).
     */
    saveDeploymentManifest(): Promise<void>;
    /** @internal
     * @return {PathBuf} - Directory where deployment manifest files are to be written.
     * */
    deploymentManifestDir(): PathBuf;
    /** @internal
     * @return {PathBuf} - File stem of the deployment manifest file
     * */
    deploymentManifestStem(): string;
    /** @internal
     * @return {PathBuf} - Full path to the deployment manifest file
     * */
    deploymentManifestPath(): PathBuf;
    /** @internal
     * @return {PathBuf} - Full path to the file indicating that the deployment
     * has been bridged
     * */
    deploymentManifestBridgedPath(): PathBuf;
}
